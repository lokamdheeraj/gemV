


#include <vector>

#include "base/vulnerability/vul_main.hh"

struct  RL
{
enum Access1 {
	READ1,
    	WRITE1
};
	Access1 preOp;
	Tick lastRead;
	Tick lastWrite;

};

class RegLiveNess
{

public:
enum Access1 {
	READ1,
    	WRITE1
};

std::vector<RL> regLiveNess;

	//Access1 preOp;
	//Tick lastRead;
	//Tick lastWrite;
	//RegLiveNess();
	//~RegLiveNess();

RegLiveNess()
{
	
    
    for(unsigned i = 0; i < 300; ++i) {
        RL regLiveNess1;

	regLiveNess1.lastRead = 0;
	regLiveNess1.lastWrite = 0;
	regLiveNess1.preOp = (RL::Access1) READ1;

        regLiveNess.push_back(regLiveNess1);

    }


}
void onRead(int idx)
{
//if(regLiveNess[idx].preOp == (RL::Access1) READ1 && regLiveNess[idx].lastRead) return;

 //std::cout << "lastRead for reg [" <<idx<<"] is " <<  curTick() << "\n";
regLiveNess[idx].lastRead = curTick();
regLiveNess[idx].preOp = (RL::Access1) READ1;

}
long onWrite(int idx, long &readTime)
{

long templive=0;
if (regLiveNess[idx].preOp == (RL::Access1) READ1  && regLiveNess[idx].lastRead)
	{
		
		templive = regLiveNess[idx].lastRead - regLiveNess[idx].lastWrite;
//std::cout << regLiveNess[idx].lastRead  << " - " << regLiveNess[idx].lastWrite <<"\n";
//DPRINTF(regLiveNess, "last read was @\n". regLiveNess[idx].lastRead );
readTime = regLiveNess[idx].lastRead;
		

	}
regLiveNess[idx].lastWrite = curTick();
regLiveNess[idx].lastRead = 0;
regLiveNess[idx].preOp = (RL::Access1) WRITE1;
return templive;

}

~RegLiveNess()
{

}
};
